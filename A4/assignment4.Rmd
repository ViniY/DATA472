---
title: "DATA202/472 - 2021 - Assignment 4"
author: "Vincent Yu 300390526"
date: "5/17/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, include = TRUE)
```


#### Due: 4:00 pm, Thursday 20 May 2021, worth 10%



### Problem 1


In lecture, we defined a geometrically distributed random variable $X$ as representing the **number of failures before first success in a sequence of Bernoulli trials**. So, we write $X \sim \mbox{Geom}(p)$, if $X$ is equal to the number of failures *before* first success in a sequence of Bernoulli trials with probability of success $p$.

**Note:** Recall that a sequence of Bernoulli trials satisfies the following assumptions:

1. Each trial has two possible outcomes, called success and failure.

2. The trials are independent. 

3. On each trial, the probability of success is  $p$  and the probability of failure is  $1âˆ’p$,  where  $p\in(0,1]$.

 a. **[4 marks]** Write a function `rgeometric` to generate $n$ observations from $X \sim \mbox{Geom}(p)$ that has arguments identical to the `rgeom` function.  Your function should use the definition of the geometric random variable as equal to the **number of failures before first success** in a sequence of Bernoulli trials. You may **not** use the `rgeom` function, but instead should use either the `sample` or `runif` function for simulating Bernoulli outcomes.  Your function does not need to perform error handling (*i.e.*, you may assume that inputs will be provided correctly).   Run your code, with set.seed(0), to generate 5 observations form $X \sim \mbox{Geom}(0.7)$.

## Solution:
The function take two arguments, the first is the number of observations needed, and the second argument is the probability of success. And the function will return a vector contains the number of failures before first succcess. The function will set seed to 0. The counter start with zero, since it is counting the faliure time. It will be zero when first into the while loop, and if we success at the first time, the counter will be 0 (no faliures), and if we success in the second time the counter will be 1 (1 faliure), and the rest of situations are similar. 
```{r  echo=TRUE,error=TRUE, eval=TRUE, include= TRUE}
rgeometric = function( num = 5, p = 0.5){

    # num used to specify sample size 
    # Set the seed for generating a random number.
      vector= c()
      n = 0
      counter = -1
      while(n<num){
          counter = counter + 1 
          temper <- runif(1,min = 0,max = 1)
          #temp <- sample(x= c(0,1), size= 1, replace =TRUE, prob = c(p,1-p))
          #print(temper)
          if (temper <= p){
          #if (temp<1){
            vector = append(vector,counter)
            counter = -1
            n = n + 1
          }

      }
    return (vector)
}
set.seed(0)
x = rgeometric(5,0.7)
x
```
# 1.b 

```{r  echo=TRUE,error=TRUE, eval=TRUE, include= TRUE}
n = 100000
set.seed(0)
b.x = rgeometric(n,0.7)
```

```{r  echo=TRUE,error=TRUE, eval=TRUE, include= TRUE}

p = 0.7
expectedValue = (1-p)/p
cat("The calculated EV using formula : ", expectedValue, "\n")
cat("The Estimated EV : ", mean(b.x), "\n")

varianceCalculated = (1-p)/(p*p)
cat("The calculated variance using formula : ", varianceCalculated, "\n")

xEV = mean(b.x)
s2 =(sum((b.x-xEV)**2))/(n-1)
cat("The estimated variance : ", s2, "\n")

```

c. **[1 marks]**  What are the theoretical expected value and variance for a $X \sim \mbox{Geom}(0.7)$? Comment on how well these values compare with the estimated expected value and variance of $X \sim \mbox{Geom}(0.7)$ in part b.


# Solution to 1.c
The estimated value is very close to the theoretical value, however they are not exactly the same, but if we increase the sample size, it can be even closer. The theoretical expected value is  0.4285714  and the estimated EV is 0.42946, hence the estimated EV is very close to theoretical value. And the esitmated Variance is 0.6102902 and the theoretical variance is 0.6122449, the two values are very close. 

d. **[4 marks]**  Write a function `dgeometric` to estimate $P(X=x)$ using $n$ observations of $X \sim \mbox{Geom}(p)$ generated by your function `rgeometric` (in part a.) (if your function `rgeometric` does not work properly, use `rgeom`). Your function `dgeometric` does not need to perform error handling (*i.e.*, you may assume that inputs will be provided correctly). Run your code, with set.seed(0) and $n=100000$, to estimate $P(X=2)$ for $X \sim \mbox{Geom}(0.7)$.  **Hint:** You might find `table()` command useful.

```{r  echo=TRUE,error=TRUE, eval=TRUE, include= TRUE}
# take three input as argument, x-> desired x value , num-> size of observation, sucProb -> success rate
dgeometric = function (x ,num, sucProb){
  rs = rgeometric(num, sucProb)
  counter = 0

  for(var in rs){
    if (var == x){
      counter = counter + 1 
    }
  }
  
  prob = counter/num
  return (prob)
}


```

# Estimate P(x= 2)  :
```{r  echo=TRUE,error=TRUE, eval=TRUE, include= TRUE}
n = 100000 
sucProb = 0.7
x = 2
set.seed(0)


prob.x.2 = dgeometric(x, n, sucProb)
cat("P(x=2) approximately should be : ", prob.x.2)
```



e. **[1 marks]**  Compute the theoretical value of $P(X=2)$ for $X \sim \mbox{Geom}(0.7)$. How the result in d. compares with this theoretical value?
```{r  echo=TRUE,error=TRUE, eval=TRUE, include= TRUE}
p = 0.7
x = 2 
theoretical =( (1- p )** (x)) * p
cat("Theoretical P(X=2) :  ", theoretical)
```
From the estimate result, we have $P(X=2)\approx 0.212 $ and  theoretically $P(X=2) = 0.21$. The estimated value is very close to the calculated value.
### Problem 2


Let $X$ be a negative binomial random variable with parameters $(r, p)$, i.e., X represents **the number of failures before the r-th success** in a sequence of Bernoulli trails with probability of success $p$. We use the following notation $X \sim NBin(r, p)$. It can be shown that $NBin(r,p)$ random variable can be represented as a sum of $r$ independent  $Geom(p)$ random variables. Also, as expected, $$E(X) = \frac{r(1-p)}{p} \hspace{2ex} \mbox{and} \hspace{2ex} Var(X) = \frac{r(1-p)}{p^2}.$$

 a. **[4 marks]** Write a function `rnbinomial` to generate $n$ observations from  $X \sim NBin(r, p)$ that uses the representation of the negative binomial random variable as a sum of $r$ independent $Geom(p)$ random variables. You may **not** use the `rnbinom` or `rgeom` functions, but instead should use your function `rgeometric` from Problem 1, part a. (if your function `rgeometric` does not work properly, use `rgeom`). Your function does not need to perform error handling (*i.e.*, you may assume that inputs will be provided correctly). Run your function, with set.seed(0), to generate 5 observations from $X \sim NBin(3, 0.7)$.

```{r  echo=TRUE,error=TRUE, eval=TRUE, include= TRUE}
rnbinomial = function(r,p){
  faliures = sum( rgeometric(r,p))
  return (faliures)
}


```

```{r  echo=TRUE,error=TRUE, eval=TRUE, include= TRUE}
set.seed(0)
vec = c()
n = 0
r = 3
p = 0.7
while(n<5){
  
  faliure = rnbinomial(r,p)
  vec = append(vec,faliure)
  n = n+1
}
print(vec)
```


b. **[2 marks]**  Write a function to estimate the expected value and variance for $X \sim \mbox{NBin}(r, p)$ using $n$ observations simulated by your function `rnbinomial` (or `rnbinom` if your function `rnbinomial` is not working correctly).  Your function does not need to perform error handling (*i.e.*, you may assume that inputs will be provided correctly). Run your code, with set.seed(0) and $n =100000$ to estimate the expected value and variance for $X \sim \mbox{NBin}(3, 0.7)$. 

```{r  echo=TRUE,error=TRUE, eval=TRUE, include= TRUE}
set.seed(0)
n = 100000
counter = 0 
r = 3
p = 0.7
vec.b = c()
while(counter<n){
  faliure = rnbinomial(r,p)
  vec.b = append(vec.b,faliure)
  counter = counter + 1
}


```

```{r  echo=TRUE,error=TRUE, eval=TRUE, include= TRUE}
expectValue = mean(vec.b)
variance = var(vec.b)
calMean = r*(1-p)/p
calVar = 3* (1-p)/(p**2)
cat("The Estimated EV : ",expectValue, "\n")
cat("The Estimated Variance : ",variance, "\n")
cat("The Calculated  EV : ",calMean, "\n")
cat("The Calculated Variance : ",calVar, "\n")
```
# check with rnbinom function (the base function built in)
```{r  echo=TRUE,error=TRUE, eval=TRUE, include= TRUE}
t = rnbinom(100000,3,0.7)
mean(t)
var(t)
```


c. **[2 marks]**  Compute the theoretical values $E(X)$ and $Var(X)$ for $X \sim \mbox{NBin}(3, 0.7)$.  Comment on how well these values compare with the estimated  expected value and variance of $X \sim \mbox{NBin}(3, 0.7)$ in part b.

## Comment:
# From the results shown above, the expected values of estimated and theoretical are very close, and the estimated variance is also very close to the theoretical variance. 
# Also checked with the built in function : rnbinom which gave similar result. 

### Problem 3

Consider the following die game: (1) You are allowed to roll a die **up to 6 times;** (2)  At any time during the game, after observing the outcome of the roll, you may **stop ** the game, and you win the dollar amount shown on that roll. For example, your rolls are 5, 1, 3, 4, and you **decide  to stop** the game, then you win $4; your rolls are 5, 1, 3, 4, 3, 2,  with **no decision to stop the game**, then you win $2. 


 a. **[2 marks]** Write a function to compute your expected winnings over $n$ game plays, assuming that **you stop the game** only if you get 6 on your roll?  Estimate your expected winnings over $n = 100000$ game plays, using set.seed(0).
 
## algorithm overview, the functions in these questions are following the same pattern.
## the outter while loop controls how many games, and the inner while loop controls roll 6 times in one game
## if we get the number we want says greater than 4 then we stop the current game and add the value to the moneyCanWin variable, and change the stop sign to true which will
## skip the rest rolls in the game
## and if we roll 6 times and still do not have any number satisfy the requirement, then the moneyCanWin variable will add the last number rolled. 
## Finally, the function returns the amount of money we can earn after n games. 
 
```{r  echo=TRUE,error=TRUE, eval=TRUE, include= TRUE}
WinningValues.6 = function(n){
  moneyCanWin = 0 
  index= 0
  while(index < n){
  t = sample(1:6, size= 6, replace = TRUE)
  
  if(6%in% t ){ # if we have a six in the six rolls then take a 6 to money can win variable
       moneyCanWin = moneyCanWin + 6
     }
  else{ # here means we do not have a any "6" in the six rolls then take the last one
       moneyCanWin = moneyCanWin + t[6]
     }
  
      index = index + 1 
  }
    
  
  
  return(moneyCanWin)
}
```

```{r  echo=TRUE,error=TRUE, eval=TRUE, include= TRUE}
set.seed(0)
n = 100000
result.6 = WinningValues.6(n)
cat("Over 100000 games, we can win $", result.6, "Stop only when roll 6 \n"  )
cat("Over 100000 games, the expected value is " , result.6/n)
```


b. **[2 marks]**  Let us assume you keep rolling until you get (4 or greater), then you stop the game. Write a function to compute your expected winnings under this scenario over $n$ game plays? What are your expected winnings over $n=100000$ game plays, using set.seed(0).

```{r  echo=TRUE,error=TRUE, eval=TRUE, include= TRUE}
WinningValues.4 = function(n){
  set.seed(0)
  moneyCanWin = 0 
  index= 0
  while (index<n) {
    t = sample(1:6, size= 6, replace = TRUE)

    indexOfGreaterThan<-which(t>=4)

  if(length(indexOfGreaterThan) > 0){ # if we have a number greater than in the six rolls then take a 6 to money can win variable
       moneyCanWin = moneyCanWin + t[min(indexOfGreaterThan)]
  }
  else{ # here means we do not have a any number greater than 4 in the six rolls then take the last one
       moneyCanWin = moneyCanWin + t[6]
     }
    index = index + 1
  }
  return(moneyCanWin)
}


```

```{r  echo=TRUE,error=TRUE, eval=TRUE, include= TRUE}
set.seed(0)
n = 100000 
result.4 = WinningValues.4(n)


cat("Over 100000 games , we can win $ ", result.4, "Stop when roll number greater or equal to 4 \n" )
cat("Over 100000 games, the expected value is " , result.6/n)

```

c. **[2 marks]**  Let us assume you stop the game if you get  ($k$ or greater), where $k$ could be  $\{1, 2, \ldots, 6\}$, on your roll. Write a function to determine, over $n$  game plays,  what value of $k$ gives you the maximum expected winnings, and the value of these expected winnings.  Run your code with $n=100000$ and set.seed(0). 

```{r  echo=TRUE,error=TRUE, eval=TRUE, include= TRUE}

WinningValues.k= function(n, k){
  set.seed(0)
  moneyCanWin = 0 
  index= 0
  countRolls =0 
  stop =FALSE
  while (index<n) {
  
  stop =FALSE
  countRolls =0 
    while(countRolls<6){
      if (!stop){
      t = sample(x=c(1,2,3,4,5,6), size= 1,replace = TRUE)
        if(t>=k){
          moneyCanWin = moneyCanWin + t
          stop = TRUE
        }
      countRolls = countRolls + 1 
      }
      else{
              countRolls = countRolls + 1 

      }
      
    }
    # if throw 6 times still no number satisfy us then take the last one

    if (!stop){
      moneyCanWin = moneyCanWin + t
      stop = FALSE
    }
    
    index = index + 1
  }
  return(moneyCanWin)
}


```

```{r  echo=TRUE,error=TRUE, eval=TRUE, include= TRUE}
set.seed(0)
n = 100000
result.k.6 = WinningValues.k(n,6)
set.seed(0)

result.k.5 = WinningValues.k(n,5)
set.seed(0)

result.k.4 = WinningValues.k(n,4)
set.seed(0)

result.k.3 = WinningValues.k(n,3)
set.seed(0)

result.k.2 = WinningValues.k(n,2)
set.seed(0)

result.k.1 = WinningValues.k(n,1)

cat("Over 100000 games , we can win ", result.k.6, " stop only when 6 \n" )
cat("Over 100000 games, the expected value is " , result.k.6/n, "\n")

cat("Over 100000 games , we can win ", result.k.5, " stop only when greater or equal to 5 \n" )
cat("Over 100000 games, the expected value is " , result.k.5/n, "\n")

cat("Over 100000 games , we can win ", result.k.4, " stop only when greater or equal to 4\n" )
cat("Over 100000 games, the expected value is " , result.k.4/n, "\n")

cat("Over 100000 games , we can win ", result.k.3, " stop only when greater or equal to 3 \n" )
cat("Over 100000 games, the expected value is " , result.k.3/n, "\n")

cat("Over 100000 games , we can win ", result.k.2, " stop only when greater or equal to 2 \n" )
cat("Over 100000 games, the expected value is " , result.k.2/n, "\n")

cat("Over 100000 games , we can win ", result.k.1, " stop only when greater or equal to 1 \n" )
cat("Over 100000 games, the expected value is " , result.k.1/n, "\n")


```
# From the result, we can see if we stop roll when the value is greater or equal to 5 we can have the maximum value over 100000 games

c. **[2 marks]**  What is the probability to stop the game because you rolled 6? Use 100000 game plays, with set.seed(0), to estimate this probability.

```{r  echo=TRUE,error=TRUE, eval=TRUE, include= TRUE}
prob.6 = function(n){
  times = 0
  index= 0
  countRolls =0 
  stop = FALSE
  while (index<n) {
  countRolls =0 
  stop = FALSE
    while(countRolls<6){
      if (!stop){
      t = sample(x=c(1,2,3,4,5,6), size= 1,replace = TRUE)
      if(t==6){
        times = times + 1
        stop = TRUE
        }
      }
      countRolls = countRolls + 1 
    }
    index = index + 1
  }
  
  return(times/n)
}
set.seed(0)
n = 100000
prob.6.result = prob.6(n)
cat("Over 100000, the probability of stop when roll 6 is : ",prob.6.result )

```
 
d. **[2 marks]**  Can `pgeom` be used  to find the probability that the game has been stopped because you rolled 6? Please justify your answer.
pgeom is the cumulative probability of less than or equal to n faliures prior to success. And the funtion has two argument q and prob been used. "q" stand for the maximum trails and prob is the probability of success occurs. In this problem, we can set $p = \frac{1}{6}$ which is the probability of rolling a "6" from a die. And set $q=5$ which is the maximum faliures we can have in this game. Since, we can only have 6 rolls in the game, and to success we need one roll to have a "6", so we can only have 5 faliures at maximum. The function pgeom can provide a similar probability of estimated probability from previous question. 
```{r  echo=TRUE,error=TRUE, eval=TRUE, include= TRUE}
pgeom(5,1/6)
```

### Problem 4

**[10 marks]** The objective of the game Yahtzee is to score points by rolling simulataneously five fair dice to get certain combinations. We consider a simplified version of the game, such that each round of the game consists only one roll of the five dice.

A combination is called `Yahtzee` if it is five-of-a-kind and scores 50 points. It is the highest scoring combination.
Estimate the probability of getting an Yahtzee using 100000 rounds of the game and set.seed(0).

```{r  echo=TRUE,error=TRUE, eval=TRUE, include= TRUE}
gameStart = function(n){
  index = 0
  counter = 0
  while(index<n){
    r = sample(x=c(1,2,3,4,5,6), size = 5, replace = TRUE)
    ## if five of one kind then after take unique value the length should be one
    rr =unique(r)
    if (length(rr)==1){
      counter = counter + 1
    }
    index = index +1
  }
  
  
  return (counter)
  
}

```
```{r  echo=TRUE,error=TRUE, eval=TRUE, include= TRUE}
set.seed(0)
n = 100000
numbers = gameStart(n)
probability.yahtzee = numbers/n

cat(" The probability of getting an Yahtzee should be : ", probability.yahtzee)
```





#### (Assignment total: 40 Marks)